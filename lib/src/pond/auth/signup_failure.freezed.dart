// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'signup_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$SignupFailureTearOff {
  const _$SignupFailureTearOff();

  InvalidEmailSignupFailure invalidEmail() {
    return const InvalidEmailSignupFailure();
  }

  EmailAlreadyUsedSignupFailure emailAlreadyUsed() {
    return const EmailAlreadyUsedSignupFailure();
  }

  WeakPasswordSignupFailure weakPassword() {
    return const WeakPasswordSignupFailure();
  }

  OtherSignupFailure other() {
    return const OtherSignupFailure();
  }
}

/// @nodoc
const $SignupFailure = _$SignupFailureTearOff();

/// @nodoc
mixin _$SignupFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmail,
    required TResult Function() emailAlreadyUsed,
    required TResult Function() weakPassword,
    required TResult Function() other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmail,
    TResult Function()? emailAlreadyUsed,
    TResult Function()? weakPassword,
    TResult Function()? other,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmailSignupFailure value) invalidEmail,
    required TResult Function(EmailAlreadyUsedSignupFailure value)
        emailAlreadyUsed,
    required TResult Function(WeakPasswordSignupFailure value) weakPassword,
    required TResult Function(OtherSignupFailure value) other,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmailSignupFailure value)? invalidEmail,
    TResult Function(EmailAlreadyUsedSignupFailure value)? emailAlreadyUsed,
    TResult Function(WeakPasswordSignupFailure value)? weakPassword,
    TResult Function(OtherSignupFailure value)? other,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SignupFailureCopyWith<$Res> {
  factory $SignupFailureCopyWith(
          SignupFailure value, $Res Function(SignupFailure) then) =
      _$SignupFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$SignupFailureCopyWithImpl<$Res>
    implements $SignupFailureCopyWith<$Res> {
  _$SignupFailureCopyWithImpl(this._value, this._then);

  final SignupFailure _value;
  // ignore: unused_field
  final $Res Function(SignupFailure) _then;
}

/// @nodoc
abstract class $InvalidEmailSignupFailureCopyWith<$Res> {
  factory $InvalidEmailSignupFailureCopyWith(InvalidEmailSignupFailure value,
          $Res Function(InvalidEmailSignupFailure) then) =
      _$InvalidEmailSignupFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidEmailSignupFailureCopyWithImpl<$Res>
    extends _$SignupFailureCopyWithImpl<$Res>
    implements $InvalidEmailSignupFailureCopyWith<$Res> {
  _$InvalidEmailSignupFailureCopyWithImpl(InvalidEmailSignupFailure _value,
      $Res Function(InvalidEmailSignupFailure) _then)
      : super(_value, (v) => _then(v as InvalidEmailSignupFailure));

  @override
  InvalidEmailSignupFailure get _value =>
      super._value as InvalidEmailSignupFailure;
}

/// @nodoc

class _$InvalidEmailSignupFailure implements InvalidEmailSignupFailure {
  const _$InvalidEmailSignupFailure();

  @override
  String toString() {
    return 'SignupFailure.invalidEmail()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidEmailSignupFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmail,
    required TResult Function() emailAlreadyUsed,
    required TResult Function() weakPassword,
    required TResult Function() other,
  }) {
    return invalidEmail();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmail,
    TResult Function()? emailAlreadyUsed,
    TResult Function()? weakPassword,
    TResult Function()? other,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmailSignupFailure value) invalidEmail,
    required TResult Function(EmailAlreadyUsedSignupFailure value)
        emailAlreadyUsed,
    required TResult Function(WeakPasswordSignupFailure value) weakPassword,
    required TResult Function(OtherSignupFailure value) other,
  }) {
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmailSignupFailure value)? invalidEmail,
    TResult Function(EmailAlreadyUsedSignupFailure value)? emailAlreadyUsed,
    TResult Function(WeakPasswordSignupFailure value)? weakPassword,
    TResult Function(OtherSignupFailure value)? other,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmailSignupFailure implements SignupFailure {
  const factory InvalidEmailSignupFailure() = _$InvalidEmailSignupFailure;
}

/// @nodoc
abstract class $EmailAlreadyUsedSignupFailureCopyWith<$Res> {
  factory $EmailAlreadyUsedSignupFailureCopyWith(
          EmailAlreadyUsedSignupFailure value,
          $Res Function(EmailAlreadyUsedSignupFailure) then) =
      _$EmailAlreadyUsedSignupFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$EmailAlreadyUsedSignupFailureCopyWithImpl<$Res>
    extends _$SignupFailureCopyWithImpl<$Res>
    implements $EmailAlreadyUsedSignupFailureCopyWith<$Res> {
  _$EmailAlreadyUsedSignupFailureCopyWithImpl(
      EmailAlreadyUsedSignupFailure _value,
      $Res Function(EmailAlreadyUsedSignupFailure) _then)
      : super(_value, (v) => _then(v as EmailAlreadyUsedSignupFailure));

  @override
  EmailAlreadyUsedSignupFailure get _value =>
      super._value as EmailAlreadyUsedSignupFailure;
}

/// @nodoc

class _$EmailAlreadyUsedSignupFailure implements EmailAlreadyUsedSignupFailure {
  const _$EmailAlreadyUsedSignupFailure();

  @override
  String toString() {
    return 'SignupFailure.emailAlreadyUsed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmailAlreadyUsedSignupFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmail,
    required TResult Function() emailAlreadyUsed,
    required TResult Function() weakPassword,
    required TResult Function() other,
  }) {
    return emailAlreadyUsed();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmail,
    TResult Function()? emailAlreadyUsed,
    TResult Function()? weakPassword,
    TResult Function()? other,
    required TResult orElse(),
  }) {
    if (emailAlreadyUsed != null) {
      return emailAlreadyUsed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmailSignupFailure value) invalidEmail,
    required TResult Function(EmailAlreadyUsedSignupFailure value)
        emailAlreadyUsed,
    required TResult Function(WeakPasswordSignupFailure value) weakPassword,
    required TResult Function(OtherSignupFailure value) other,
  }) {
    return emailAlreadyUsed(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmailSignupFailure value)? invalidEmail,
    TResult Function(EmailAlreadyUsedSignupFailure value)? emailAlreadyUsed,
    TResult Function(WeakPasswordSignupFailure value)? weakPassword,
    TResult Function(OtherSignupFailure value)? other,
    required TResult orElse(),
  }) {
    if (emailAlreadyUsed != null) {
      return emailAlreadyUsed(this);
    }
    return orElse();
  }
}

abstract class EmailAlreadyUsedSignupFailure implements SignupFailure {
  const factory EmailAlreadyUsedSignupFailure() =
      _$EmailAlreadyUsedSignupFailure;
}

/// @nodoc
abstract class $WeakPasswordSignupFailureCopyWith<$Res> {
  factory $WeakPasswordSignupFailureCopyWith(WeakPasswordSignupFailure value,
          $Res Function(WeakPasswordSignupFailure) then) =
      _$WeakPasswordSignupFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$WeakPasswordSignupFailureCopyWithImpl<$Res>
    extends _$SignupFailureCopyWithImpl<$Res>
    implements $WeakPasswordSignupFailureCopyWith<$Res> {
  _$WeakPasswordSignupFailureCopyWithImpl(WeakPasswordSignupFailure _value,
      $Res Function(WeakPasswordSignupFailure) _then)
      : super(_value, (v) => _then(v as WeakPasswordSignupFailure));

  @override
  WeakPasswordSignupFailure get _value =>
      super._value as WeakPasswordSignupFailure;
}

/// @nodoc

class _$WeakPasswordSignupFailure implements WeakPasswordSignupFailure {
  const _$WeakPasswordSignupFailure();

  @override
  String toString() {
    return 'SignupFailure.weakPassword()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is WeakPasswordSignupFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmail,
    required TResult Function() emailAlreadyUsed,
    required TResult Function() weakPassword,
    required TResult Function() other,
  }) {
    return weakPassword();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmail,
    TResult Function()? emailAlreadyUsed,
    TResult Function()? weakPassword,
    TResult Function()? other,
    required TResult orElse(),
  }) {
    if (weakPassword != null) {
      return weakPassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmailSignupFailure value) invalidEmail,
    required TResult Function(EmailAlreadyUsedSignupFailure value)
        emailAlreadyUsed,
    required TResult Function(WeakPasswordSignupFailure value) weakPassword,
    required TResult Function(OtherSignupFailure value) other,
  }) {
    return weakPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmailSignupFailure value)? invalidEmail,
    TResult Function(EmailAlreadyUsedSignupFailure value)? emailAlreadyUsed,
    TResult Function(WeakPasswordSignupFailure value)? weakPassword,
    TResult Function(OtherSignupFailure value)? other,
    required TResult orElse(),
  }) {
    if (weakPassword != null) {
      return weakPassword(this);
    }
    return orElse();
  }
}

abstract class WeakPasswordSignupFailure implements SignupFailure {
  const factory WeakPasswordSignupFailure() = _$WeakPasswordSignupFailure;
}

/// @nodoc
abstract class $OtherSignupFailureCopyWith<$Res> {
  factory $OtherSignupFailureCopyWith(
          OtherSignupFailure value, $Res Function(OtherSignupFailure) then) =
      _$OtherSignupFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$OtherSignupFailureCopyWithImpl<$Res>
    extends _$SignupFailureCopyWithImpl<$Res>
    implements $OtherSignupFailureCopyWith<$Res> {
  _$OtherSignupFailureCopyWithImpl(
      OtherSignupFailure _value, $Res Function(OtherSignupFailure) _then)
      : super(_value, (v) => _then(v as OtherSignupFailure));

  @override
  OtherSignupFailure get _value => super._value as OtherSignupFailure;
}

/// @nodoc

class _$OtherSignupFailure implements OtherSignupFailure {
  const _$OtherSignupFailure();

  @override
  String toString() {
    return 'SignupFailure.other()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is OtherSignupFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmail,
    required TResult Function() emailAlreadyUsed,
    required TResult Function() weakPassword,
    required TResult Function() other,
  }) {
    return other();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmail,
    TResult Function()? emailAlreadyUsed,
    TResult Function()? weakPassword,
    TResult Function()? other,
    required TResult orElse(),
  }) {
    if (other != null) {
      return other();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmailSignupFailure value) invalidEmail,
    required TResult Function(EmailAlreadyUsedSignupFailure value)
        emailAlreadyUsed,
    required TResult Function(WeakPasswordSignupFailure value) weakPassword,
    required TResult Function(OtherSignupFailure value) other,
  }) {
    return other(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmailSignupFailure value)? invalidEmail,
    TResult Function(EmailAlreadyUsedSignupFailure value)? emailAlreadyUsed,
    TResult Function(WeakPasswordSignupFailure value)? weakPassword,
    TResult Function(OtherSignupFailure value)? other,
    required TResult orElse(),
  }) {
    if (other != null) {
      return other(this);
    }
    return orElse();
  }
}

abstract class OtherSignupFailure implements SignupFailure {
  const factory OtherSignupFailure() = _$OtherSignupFailure;
}
