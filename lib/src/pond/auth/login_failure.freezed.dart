// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'login_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$LoginFailureTearOff {
  const _$LoginFailureTearOff();

  InvalidEmailLoginFailure invalidEmail() {
    return const InvalidEmailLoginFailure();
  }

  UserDisabledLoginFailure userDisabled() {
    return const UserDisabledLoginFailure();
  }

  UserNotFoundLoginFailure userNotFound() {
    return const UserNotFoundLoginFailure();
  }

  WrongPasswordLoginFailure wrongPassword() {
    return const WrongPasswordLoginFailure();
  }
}

/// @nodoc
const $LoginFailure = _$LoginFailureTearOff();

/// @nodoc
mixin _$LoginFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmail,
    required TResult Function() userDisabled,
    required TResult Function() userNotFound,
    required TResult Function() wrongPassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmail,
    TResult Function()? userDisabled,
    TResult Function()? userNotFound,
    TResult Function()? wrongPassword,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmailLoginFailure value) invalidEmail,
    required TResult Function(UserDisabledLoginFailure value) userDisabled,
    required TResult Function(UserNotFoundLoginFailure value) userNotFound,
    required TResult Function(WrongPasswordLoginFailure value) wrongPassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmailLoginFailure value)? invalidEmail,
    TResult Function(UserDisabledLoginFailure value)? userDisabled,
    TResult Function(UserNotFoundLoginFailure value)? userNotFound,
    TResult Function(WrongPasswordLoginFailure value)? wrongPassword,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoginFailureCopyWith<$Res> {
  factory $LoginFailureCopyWith(
          LoginFailure value, $Res Function(LoginFailure) then) =
      _$LoginFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginFailureCopyWithImpl<$Res> implements $LoginFailureCopyWith<$Res> {
  _$LoginFailureCopyWithImpl(this._value, this._then);

  final LoginFailure _value;
  // ignore: unused_field
  final $Res Function(LoginFailure) _then;
}

/// @nodoc
abstract class $InvalidEmailLoginFailureCopyWith<$Res> {
  factory $InvalidEmailLoginFailureCopyWith(InvalidEmailLoginFailure value,
          $Res Function(InvalidEmailLoginFailure) then) =
      _$InvalidEmailLoginFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidEmailLoginFailureCopyWithImpl<$Res>
    extends _$LoginFailureCopyWithImpl<$Res>
    implements $InvalidEmailLoginFailureCopyWith<$Res> {
  _$InvalidEmailLoginFailureCopyWithImpl(InvalidEmailLoginFailure _value,
      $Res Function(InvalidEmailLoginFailure) _then)
      : super(_value, (v) => _then(v as InvalidEmailLoginFailure));

  @override
  InvalidEmailLoginFailure get _value =>
      super._value as InvalidEmailLoginFailure;
}

/// @nodoc

class _$InvalidEmailLoginFailure implements InvalidEmailLoginFailure {
  const _$InvalidEmailLoginFailure();

  @override
  String toString() {
    return 'LoginFailure.invalidEmail()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidEmailLoginFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmail,
    required TResult Function() userDisabled,
    required TResult Function() userNotFound,
    required TResult Function() wrongPassword,
  }) {
    return invalidEmail();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmail,
    TResult Function()? userDisabled,
    TResult Function()? userNotFound,
    TResult Function()? wrongPassword,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmailLoginFailure value) invalidEmail,
    required TResult Function(UserDisabledLoginFailure value) userDisabled,
    required TResult Function(UserNotFoundLoginFailure value) userNotFound,
    required TResult Function(WrongPasswordLoginFailure value) wrongPassword,
  }) {
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmailLoginFailure value)? invalidEmail,
    TResult Function(UserDisabledLoginFailure value)? userDisabled,
    TResult Function(UserNotFoundLoginFailure value)? userNotFound,
    TResult Function(WrongPasswordLoginFailure value)? wrongPassword,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmailLoginFailure implements LoginFailure {
  const factory InvalidEmailLoginFailure() = _$InvalidEmailLoginFailure;
}

/// @nodoc
abstract class $UserDisabledLoginFailureCopyWith<$Res> {
  factory $UserDisabledLoginFailureCopyWith(UserDisabledLoginFailure value,
          $Res Function(UserDisabledLoginFailure) then) =
      _$UserDisabledLoginFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserDisabledLoginFailureCopyWithImpl<$Res>
    extends _$LoginFailureCopyWithImpl<$Res>
    implements $UserDisabledLoginFailureCopyWith<$Res> {
  _$UserDisabledLoginFailureCopyWithImpl(UserDisabledLoginFailure _value,
      $Res Function(UserDisabledLoginFailure) _then)
      : super(_value, (v) => _then(v as UserDisabledLoginFailure));

  @override
  UserDisabledLoginFailure get _value =>
      super._value as UserDisabledLoginFailure;
}

/// @nodoc

class _$UserDisabledLoginFailure implements UserDisabledLoginFailure {
  const _$UserDisabledLoginFailure();

  @override
  String toString() {
    return 'LoginFailure.userDisabled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UserDisabledLoginFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmail,
    required TResult Function() userDisabled,
    required TResult Function() userNotFound,
    required TResult Function() wrongPassword,
  }) {
    return userDisabled();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmail,
    TResult Function()? userDisabled,
    TResult Function()? userNotFound,
    TResult Function()? wrongPassword,
    required TResult orElse(),
  }) {
    if (userDisabled != null) {
      return userDisabled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmailLoginFailure value) invalidEmail,
    required TResult Function(UserDisabledLoginFailure value) userDisabled,
    required TResult Function(UserNotFoundLoginFailure value) userNotFound,
    required TResult Function(WrongPasswordLoginFailure value) wrongPassword,
  }) {
    return userDisabled(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmailLoginFailure value)? invalidEmail,
    TResult Function(UserDisabledLoginFailure value)? userDisabled,
    TResult Function(UserNotFoundLoginFailure value)? userNotFound,
    TResult Function(WrongPasswordLoginFailure value)? wrongPassword,
    required TResult orElse(),
  }) {
    if (userDisabled != null) {
      return userDisabled(this);
    }
    return orElse();
  }
}

abstract class UserDisabledLoginFailure implements LoginFailure {
  const factory UserDisabledLoginFailure() = _$UserDisabledLoginFailure;
}

/// @nodoc
abstract class $UserNotFoundLoginFailureCopyWith<$Res> {
  factory $UserNotFoundLoginFailureCopyWith(UserNotFoundLoginFailure value,
          $Res Function(UserNotFoundLoginFailure) then) =
      _$UserNotFoundLoginFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserNotFoundLoginFailureCopyWithImpl<$Res>
    extends _$LoginFailureCopyWithImpl<$Res>
    implements $UserNotFoundLoginFailureCopyWith<$Res> {
  _$UserNotFoundLoginFailureCopyWithImpl(UserNotFoundLoginFailure _value,
      $Res Function(UserNotFoundLoginFailure) _then)
      : super(_value, (v) => _then(v as UserNotFoundLoginFailure));

  @override
  UserNotFoundLoginFailure get _value =>
      super._value as UserNotFoundLoginFailure;
}

/// @nodoc

class _$UserNotFoundLoginFailure implements UserNotFoundLoginFailure {
  const _$UserNotFoundLoginFailure();

  @override
  String toString() {
    return 'LoginFailure.userNotFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UserNotFoundLoginFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmail,
    required TResult Function() userDisabled,
    required TResult Function() userNotFound,
    required TResult Function() wrongPassword,
  }) {
    return userNotFound();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmail,
    TResult Function()? userDisabled,
    TResult Function()? userNotFound,
    TResult Function()? wrongPassword,
    required TResult orElse(),
  }) {
    if (userNotFound != null) {
      return userNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmailLoginFailure value) invalidEmail,
    required TResult Function(UserDisabledLoginFailure value) userDisabled,
    required TResult Function(UserNotFoundLoginFailure value) userNotFound,
    required TResult Function(WrongPasswordLoginFailure value) wrongPassword,
  }) {
    return userNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmailLoginFailure value)? invalidEmail,
    TResult Function(UserDisabledLoginFailure value)? userDisabled,
    TResult Function(UserNotFoundLoginFailure value)? userNotFound,
    TResult Function(WrongPasswordLoginFailure value)? wrongPassword,
    required TResult orElse(),
  }) {
    if (userNotFound != null) {
      return userNotFound(this);
    }
    return orElse();
  }
}

abstract class UserNotFoundLoginFailure implements LoginFailure {
  const factory UserNotFoundLoginFailure() = _$UserNotFoundLoginFailure;
}

/// @nodoc
abstract class $WrongPasswordLoginFailureCopyWith<$Res> {
  factory $WrongPasswordLoginFailureCopyWith(WrongPasswordLoginFailure value,
          $Res Function(WrongPasswordLoginFailure) then) =
      _$WrongPasswordLoginFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$WrongPasswordLoginFailureCopyWithImpl<$Res>
    extends _$LoginFailureCopyWithImpl<$Res>
    implements $WrongPasswordLoginFailureCopyWith<$Res> {
  _$WrongPasswordLoginFailureCopyWithImpl(WrongPasswordLoginFailure _value,
      $Res Function(WrongPasswordLoginFailure) _then)
      : super(_value, (v) => _then(v as WrongPasswordLoginFailure));

  @override
  WrongPasswordLoginFailure get _value =>
      super._value as WrongPasswordLoginFailure;
}

/// @nodoc

class _$WrongPasswordLoginFailure implements WrongPasswordLoginFailure {
  const _$WrongPasswordLoginFailure();

  @override
  String toString() {
    return 'LoginFailure.wrongPassword()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is WrongPasswordLoginFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidEmail,
    required TResult Function() userDisabled,
    required TResult Function() userNotFound,
    required TResult Function() wrongPassword,
  }) {
    return wrongPassword();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidEmail,
    TResult Function()? userDisabled,
    TResult Function()? userNotFound,
    TResult Function()? wrongPassword,
    required TResult orElse(),
  }) {
    if (wrongPassword != null) {
      return wrongPassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmailLoginFailure value) invalidEmail,
    required TResult Function(UserDisabledLoginFailure value) userDisabled,
    required TResult Function(UserNotFoundLoginFailure value) userNotFound,
    required TResult Function(WrongPasswordLoginFailure value) wrongPassword,
  }) {
    return wrongPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmailLoginFailure value)? invalidEmail,
    TResult Function(UserDisabledLoginFailure value)? userDisabled,
    TResult Function(UserNotFoundLoginFailure value)? userNotFound,
    TResult Function(WrongPasswordLoginFailure value)? wrongPassword,
    required TResult orElse(),
  }) {
    if (wrongPassword != null) {
      return wrongPassword(this);
    }
    return orElse();
  }
}

abstract class WrongPasswordLoginFailure implements LoginFailure {
  const factory WrongPasswordLoginFailure() = _$WrongPasswordLoginFailure;
}
